



Web Bot Auth                                                  T. Meunier
Internet-Draft                                                Cloudflare
Intended status: Informational                             11 April 2025
Expires: 13 October 2025


       HTTP Message Signatures for automated traffic Architecture
             draft-meunier-web-bot-auth-architecture-latest

Abstract

   This document describes an architecture for identifying automated
   traffic using [HTTP-MESSAGE-SIGNATURES].  The goal is to allow
   automated HTTP clients to cryptographically sign outbound requests,
   allowing HTTP servers to verify their identity with confidence.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://thibmeu.github.io/http-message-signatures-directory/draft-
   meunier-web-bot-auth-architecture.html.  Status information for this
   document may be found at https://datatracker.ietf.org/doc/draft-
   meunier-web-bot-auth-architecture/.

   Discussion of this document takes place on the WG Web Bot Auth
   mailing list (mailto:web-bot-auth@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/web-bot-auth/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/web-bot-auth/.

   Source for this draft and an issue tracker can be found at
   https://github.com/thibmeu/http-message-signatures-directory.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 13 October 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Motivation
   3.  Conventions and Definitions
   4.  Architecture
     4.1.  Generating HTTP Message Signature
       4.1.1.  Anti-replay
     4.2.  Requesting a Message signature
     4.3.  Validating Message signature
     4.4.  Discovery
       4.4.1.  Out-of-band communication between client and origin
       4.4.2.  Public list
       4.4.3.  Signature-Agent header
   5.  Security Considerations
   6.  Privacy Considerations
   7.  IANA Considerations
   8.  Normative References
   Acknowledgments
   Implementations
   Author's Address

1.  Introduction

   Automated agents are increasingly used for legitimate purposes,
   including AI assistants, indexing, testing, and automated support
   tools.  These agents often use general-purpose browsers, making it
   difficult for websites to authenticate or identify them.  Existing
   methods, such as IP range allowlisting or User-Agent strings, offer
   no integrity guarantees and are hard to maintain.

   This document proposes a mechanism in which outbound HTTP requests
   are signed using [HTTP-MESSAGE-SIGNATURES].  These signatures can be
   verified by receiving servers using a public key associated with the
   platform provider.  This enables trusted interactions between
   automated agents and HTTP servers, with improved security and
   manageability.

2.  Motivation

   There is an increase in automated agents on the Internet.  Some are
   honest, and want to identify themselves.  Either because origins
   pressure them to do so, because regulations mandate transparency, or
   because they are facing an increased phishing threat.  As of today
   these automated agents are left without any good solution to do so:

   1.  They share their IP range.  However that is not sustainable
       because the same IP might be used by different services, IP
       ranges may change, geolocation imposes to register IPs in
       multiple countries, and when they start allowing other companies
       to use their platform they loose control of their public facing
       reputation.

   2.  They define a User Agent per Section 10.1.5 of [HTTP].  Like curl
       uses curl/version, or Chrome uses Mozilla/5.0 ...
       Chrome/113.0.0.0.  An issue is this header is spoofable, and
       realistically automated agents are likely to use Chrome's user
       agent because otherwise they are challenged

   3.  They go to every website on the Internet and share a secret with
       them like a Bearer from [RFC6750].  This is impractical at scale.

   All this provides strong motivation to define a mechanism that
   empowers honest automated agents to share their identity.

3.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The following terms are used throughout this document:

   *User*  wants to perform some actions on the web.

   *Automated Agent*  orchestrated user agent, such as Chromium.  Can
      interact with the web, implements web standards.  For every
      request, it constructs a valid HTTP request with
      [HTTP-MESSAGE-SIGNATURES] signature.

   *Origin*  server hosting a resource.  The user wants to access it
      through the browser.

4.  Architecture

      TODO: System diagram + one more sequence diagram with key
      retrieval from the Automated Agent provider

     +---------+             +-----------------+             +--------+
     |  User   |             | Automated Agent |             | Origin |
     +----+----+             +--------+--------+             +---+----+
          |                          |                           |
          |  Help me do this!        |                           |
          +------------------------->|                           |
          |                          |  GET /path/to/resource    |
          |                          |  Signature: abc===        |
          |                          +-------------------------->|
          |                          |                           |
          |                          |     <h1>Response</h1>     |
          |                          |<--------------------------+
          |  Here are proposals      |                           |
          +<-------------------------+                           |
          |                          |                           |

   A user is asking the automated agent to do something.  The agent
   decides they need to retrieve content from an origin.  They send an
   HTTP request with a Signature header as defined in Section 3.1 of
   [HTTP-MESSAGE-SIGNATURES].  The origin validates the signature.  If
   it validates, it sends the requested content.

4.1.  Generating HTTP Message Signature

   [HTTP-MESSAGE-SIGNATURES] defines components to be signed.

   Automated agents SHOULD include the following component:

   @authority  as defined in Section 2.2.1 of [HTTP-MESSAGE-SIGNATURES]

   Automated agents SHOULD include the following @signature-params as
   defined in Section 2.3 of [HTTP-MESSAGE-SIGNATURES]

   created  as defined in Section 2.3 of [HTTP-MESSAGE-SIGNATURES]

   expires  as defined in Section 2.3 of [HTTP-MESSAGE-SIGNATURES]

   keyid  MUST be SHA256(key_bytes)

   tag  MUST be web-bot-auth

   The private key is available to the automated agent at request time.
   Algorithms should be registered with IANA as part of HTTP Message
   Signatures Algorithm registry.

   The creation of the signature is defined in Section 3.1 of
   [HTTP-MESSAGE-SIGNATURES].

4.1.1.  Anti-replay

   Origins MAY want to prevent signatures from being spoofed or used
   multiple times by bad actors and thus require a nonce to be added to
   the @signature-params.

   @signature-parameters are extended as follow

   nonce  Base10 encoded random uint32

   This nonce MUST be unique for the validity window of the signature,
   as defined by created and expires attributes.  Because the nonce is
   controlled by the client, the origin needs to maintain a list of all
   nonces that it has seen that are still in the validity window of the
   signature.

4.2.  Requesting a Message signature

   Section 5 of [HTTP-MESSAGE-SIGNATURES] defines the Accept-Signature
   field which can be used to request a Message Signature from a client
   by an origin.  Origin MAY choose to request signatures from clients
   that did not initially provide them.  If requesting, origins MUST to
   request the same parameters as those defined by the Section 4.1.

4.3.  Validating Message signature

   Upon receiving an HTTP request, the origin has to verify the
   signature.  The algorithm is provided in Section 3.2 of
   [HTTP-MESSAGE-SIGNATURES].  Similar to regular User-Agent check, this
   happens at the HTTP layer, once headers are received.

   Additional requirement are placed on this validation

   During step 4, the Origin MAY discard signatures for which the tag is
   not set to web-bot-auth.  During step 5, the Origin MAY discard
   signatures for which they do not know the keyid.  During step 5, if
   the keyid is unknown to the origin, they MAY fetch the provider
   directory as indicated by Signature-Agent header defined in Section 4
   of [DIRECTORY].

4.4.  Discovery

   This section describes the discovery mechanism for the automated
   agent directory.

   The reference for discovery is a FQDN.  It SHOULD provide a directory
   hosted on the well known registered in Section 4 of [DIRECTORY].

   We add one field to the directory defined in the other draft:
   "purpose": Ideally matches some IANA registry for preferences

   TODO: replace the key with a JWK

   Example

   {
     "keys": {
       "kty": "OKP",
       "crv": "Ed25519",
       "kid": "NFcWBst6DXG-N35nHdzMrioWntdzNZghQSkjHNMMSjw",
       "x": "JrQLj5P_89iXES9-vFgrIy29clF9CC_oPPsw3c5D0bs",
       "use": "sig",
       "nbf": 1712793600,
       "exp": 1715385600
     },
     "signature_agent": "https://directory.test",
     "purpose": "rag"
   }

4.4.1.  Out-of-band communication between client and origin

   A service submitting their key to an origin, or the origin manually
   adding a service to their trusted list

4.4.2.  Public list

   Could be a GitHub repository like the public suffix list.  The issue
   is the gating of such repositories, and therefore its governance.

4.4.3.  Signature-Agent header

   This is defined in the sibling draft.  This allows for backward
   compatibility with existing header agent filtering, and an upgrade to
   cryptographically secured protocol.

5.  Security Considerations

   Verification load

   Bigger request

   Consider batching signatures

   Shared HMAC SHOULD NOT be used

      Hint at req mTLS

6.  Privacy Considerations

   Identity is public

   The key MUST NOT identify a specific human.

7.  IANA Considerations

   This document has no IANA actions.

8.  Normative References

   [DIRECTORY]
              "HTTP Message Signatures Directory", n.d.,
              <https://thibmeu.github.io/http-message-signatures-
              directory/draft-meunier-httpbis-http-message-signatures-
              directory.html>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9110>.

   [HTTP-CACHE]
              Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Caching", STD 98, RFC 9111,
              DOI 10.17487/RFC9111, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9111>.

   [HTTP-MESSAGE-SIGNATURES]
              Backman, A., Ed., Richer, J., Ed., and M. Sporny, "HTTP
              Message Signatures", RFC 9421, DOI 10.17487/RFC9421,
              February 2024, <https://www.rfc-editor.org/rfc/rfc9421>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC6750]  Jones, M. and D. Hardt, "The OAuth 2.0 Authorization
              Framework: Bearer Token Usage", RFC 6750,
              DOI 10.17487/RFC6750, October 2012,
              <https://www.rfc-editor.org/rfc/rfc6750>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

Acknowledgments

   TODO acknowledge.

Implementations

   This draft has a couple of implementations

   Clients:

   *  Chrome MV3

   *  Cloudflare Workers

   Servers:

   *  Caddy plugin

   *  Cloudflare Workers

   A demontstration server has been deployed to https://http-message-
   signatures-example.research.cloudflare.com/ It uses RFC9421 ed25519
   test signing and verifying keys.

Author's Address

   Thibault Meunier
   Cloudflare
   Email: ot-ietf@thibault.uk
